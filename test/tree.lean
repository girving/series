import Series.Series.Tree

/-!
# Dyadic trees unit tests

This were all generated by Claude 4.5, and thus very poorly formatted and commented.
-/

open Polynomial (C X)
open scoped Polynomial
namespace Series.Tree

variable {Œ± Œ≤ ùïú : Type} {n m : ‚Ñï}

-- Test add_shift thoroughly
-- Test: (1, 2) + (3) * X = (1, 2+3, 0) = (1, 5, 0)
-- p0 = both (leaf 1) (leaf 2) represents positions [0,1)=1, [1,2)=2
-- p1 = left (leaf 3) represents positions [0,1)=3, [1,2)=0
-- Shifting p1 by 2^0 = 1: positions [1,2)=3
-- Result: positions [0,1)=1, [1,2)=5, [2,4)=0
example : add_shift (both (leaf (1 : ‚Ñ§)) (leaf 2)) (left (leaf 3)) =
    left (both (leaf 1) (leaf 5)) := rfl

-- Test: (1, 2) + (3, 4) * X = (1, 2+3, 0+4, 0) = (1, 5, 4, 0)
-- p0 = both (leaf 1) (leaf 2): [0,1)=1, [1,2)=2
-- p1 = both (leaf 3) (leaf 4): [0,1)=3, [1,2)=4
-- Shifting p1 by 1: [1,2)=3, [2,3)=4
-- Result: [0,1)=1, [1,2)=5, [2,3)=4, [3,4)=0
example : add_shift (both (leaf (1 : ‚Ñ§)) (leaf 2)) (both (leaf 3) (leaf 4)) =
    both (both (leaf 1) (leaf 5)) (left (leaf 4)) := rfl

-- Test: (1) + (2, 3) * X = (1, 2, 3, 0)
-- p0 = left (leaf 1): [0,1)=1, [1,2)=0
-- p1 = both (leaf 2) (leaf 3): [0,1)=2, [1,2)=3
-- Shifting p1 by 1: [1,2)=2, [2,3)=3
-- Result: [0,1)=1, [1,2)=2, [2,3)=3, [3,4)=0
example : add_shift (left (leaf (1 : ‚Ñ§))) (both (leaf 2) (leaf 3)) =
    both (both (leaf 1) (leaf 2)) (left (leaf 3)) := rfl

-- Test Tree.sub
-- Test: leaf - leaf = 5 - 3 = 2
example : Tree.sub (leaf (5 : ‚Ñ§)) (leaf 3) = leaf 2 := rfl

-- Test: left - leaf = (5) - 3 = (2)
example : Tree.sub (left (leaf (5 : ‚Ñ§))) (leaf 3) = left (leaf 2) := rfl

-- Test: leaf - left = 5 - (3) = (2)
example : Tree.sub (leaf (5 : ‚Ñ§)) (left (leaf 3)) = left (leaf 2) := rfl

-- Test: both - leaf = (5, 7) - 2 = (3, 7)
example : Tree.sub (both (leaf (5 : ‚Ñ§)) (leaf 7)) (leaf 2) = both (leaf 3) (leaf 7) := rfl

-- Test: both - left = (5, 7) - (2) = (3, 7)
example : Tree.sub (both (leaf (5 : ‚Ñ§)) (leaf 7)) (left (leaf 2)) = both (leaf 3) (leaf 7) := rfl

-- Test: leaf - both = 5 - (2, 3) = (3, -3)
-- Represents: 5 - (2 + 3*X) = 3 - 3*X
example : Tree.sub (leaf (5 : ‚Ñ§)) (both (leaf 2) (leaf 3)) = both (leaf 3) (leaf (-3)) := rfl

-- Test: left - both = (5) - (2, 3) = (3, -3)
example : Tree.sub (left (leaf (5 : ‚Ñ§))) (both (leaf 2) (leaf 3)) =
    both (leaf 3) (leaf (-3)) := rfl

-- Test: both - both = (10, 7) - (3, 2) = (7, 5)
example : Tree.sub (both (leaf (10 : ‚Ñ§)) (leaf 7)) (both (leaf 3) (leaf 2)) =
    both (leaf 7) (leaf 5) := rfl

-- Test: left(both) - both = ((5, 3)) - (2, 1) = ((3, 2))
example : Tree.sub (left (both (leaf (5 : ‚Ñ§)) (leaf 3))) (both (leaf 2) (leaf 1)) =
    left (both (leaf 3) (leaf 2)) := rfl

-- Test: both - left(both) = (5, 3) - ((2, 1)) = ((3, 2))
example : Tree.sub (both (leaf (5 : ‚Ñ§)) (leaf 3)) (left (both (leaf 2) (leaf 1))) =
    left (both (leaf 3) (leaf 2)) := rfl

-- Test: larger depth mismatch - ((10, 20), (30, 40)) - (5)
-- Represents: (10 + 20*X + 30*X¬≤ + 40*X¬≥) - 5 = 5 + 20*X + 30*X¬≤ + 40*X¬≥
example : Tree.sub
    (both (both (leaf (10 : ‚Ñ§)) (leaf 20)) (both (leaf 30) (leaf 40)))
    (left (leaf 5)) =
    both (both (leaf 5) (leaf 20)) (both (leaf 30) (leaf 40)) := rfl

-- Test: with negative results
-- (3, 5) - (10, 2) = (-7, 3)
example : Tree.sub (both (leaf (3 : ‚Ñ§)) (leaf 5)) (both (leaf 10) (leaf 2)) =
    both (leaf (-7)) (leaf 3) := rfl

-- Test: subtracting from zero
-- 0 - (2, 3) = (-2, -3)
example : Tree.sub (leaf (0 : ‚Ñ§)) (both (leaf 2) (leaf 3)) =
    both (leaf (-2)) (leaf (-3)) := rfl

-- Test: subtracting zero
-- (5, 7) - 0 = (5, 7)
example : Tree.sub (both (leaf (5 : ‚Ñ§)) (leaf 7)) (leaf 0) =
    both (leaf 5) (leaf 7) := rfl

-- Test: self subtraction
-- (3, 5) - (3, 5) = (0, 0)
example : Tree.sub (both (leaf (3 : ‚Ñ§)) (leaf 5)) (both (leaf 3) (leaf 5)) =
    both (leaf 0) (leaf 0) := rfl

-- Test: (5) - ((1, 2), (3, 4)) uses sub_le path
-- Represents: 5 - (1 + 2*X + 3*X¬≤ + 4*X¬≥) = 4 - 2*X - 3*X¬≤ - 4*X¬≥
example : Tree.sub
    (left (leaf (5 : ‚Ñ§)))
    (both (both (leaf 1) (leaf 2)) (both (leaf 3) (leaf 4))) =
    both (both (leaf 4) (leaf (-2))) (both (leaf (-3)) (leaf (-4))) := rfl

-- Test add_karatsuba: p0 + p1*X + p2*X^2
-- Test: (1) + (2, 3)*X + (4)*X^2 = (1, 2, 3+4, 0) = (1, 2, 7, 0)
-- p0 = left (leaf 1): [0,1)=1, [1,2)=0
-- p1 = both (leaf 2) (leaf 3): [0,1)=2, [1,2)=3
-- p2 = left (leaf 4): [0,1)=4, [1,2)=0
-- p1*X: [1,2)=2, [2,3)=3
-- p2*X^2: [2,3)=4
-- Sum: [0,1)=1, [1,2)=2, [2,3)=7, [3,4)=0
example : add_karatsuba (left (leaf (1 : ‚Ñ§))) (both (leaf 2) (leaf 3)) (left (leaf 4)) =
    both (both (leaf 1) (leaf 2)) (left (leaf 7)) := rfl

-- Test: (5, 6) + (7, 8)*X + (9, 10)*X^2 = (5, 6+7, 8+9, 10) = (5, 13, 17, 10)
-- p0 = both (leaf 5) (leaf 6): [0,1)=5, [1,2)=6
-- p1 = both (leaf 7) (leaf 8): [0,1)=7, [1,2)=8
-- p2 = both (leaf 9) (leaf 10): [0,1)=9, [1,2)=10
-- p1*X: [1,2)=7, [2,3)=8
-- p2*X^2: [2,3)=9, [3,4)=10
-- Sum: [0,1)=5, [1,2)=13, [2,3)=17, [3,4)=10
example : add_karatsuba (both (leaf (5 : ‚Ñ§)) (leaf 6)) (both (leaf 7) (leaf 8))
    (both (leaf 9) (leaf 10)) =
    both (both (leaf 5) (leaf 13)) (both (leaf 17) (leaf 10)) := rfl

-- Test: leaf √ó leaf = 2 * 3 = 6
example : muls (leaf (2 : ‚Ñ§)) (leaf 3) = left (leaf 6) := rfl

-- Test: left √ó left = (2) √ó (3) = (6)
example : muls (left (leaf (2 : ‚Ñ§))) (left (leaf 3)) =
    left (left (leaf 6)) := rfl

-- Test: left √ó both = (2) √ó (3, 5) = (6, 10)
-- Represents: 2 * (3 + 5*X) = 6 + 10*X
example : muls (left (leaf (2 : ‚Ñ§))) (both (leaf 3) (leaf 5)) =
    left (both (leaf 6) (leaf 10)) := rfl

-- Test: both √ó left = (2, 3) √ó (5) = (10, 15)
-- Represents: (2 + 3*X) * 5 = 10 + 15*X
example : muls (both (leaf (2 : ‚Ñ§)) (leaf 3)) (left (leaf 5)) =
    left (both (leaf 10) (leaf 15)) := rfl

-- Test: both √ó both = (1, 2) √ó (3, 4) = (3, 10, 8)
-- Represents: (1 + 2*X) * (3 + 4*X) = 3 + 10*X + 8*X¬≤
-- p0 = 1*3 = 3
-- p2 = 2*4 = 8
-- p1 = (1+2)*(3+4) - (3 + 8) = 3*7 - 11 = 21 - 11 = 10
example : muls (both (leaf (1 : ‚Ñ§)) (leaf 2)) (both (leaf 3) (leaf 4)) =
    both (both (leaf 3) (leaf 10)) (left (leaf 8)) := rfl

-- Test: larger both √ó both = ((1, 2), (3, 4)) √ó ((5, 6), (7, 8))
-- Represents: (1 + 2*X + 3*X¬≤ + 4*X¬≥) * (5 + 6*X + 7*X¬≤ + 8*X¬≥)
-- Expected: 5 + 16*X + 34*X¬≤ + 60*X¬≥ + 61*X‚Å¥ + 52*X‚Åµ + 32*X‚Å∂
-- This tests the recursive Karatsuba algorithm
example : muls
    (both (both (leaf (1 : ‚Ñ§)) (leaf 2)) (both (leaf 3) (leaf 4)))
    (both (both (leaf 5) (leaf 6)) (both (leaf 7) (leaf 8))) =
    both
      (both (both (leaf 5) (leaf 16)) (both (leaf 34) (leaf 60)))
      (both (both (leaf 61) (leaf 52)) (left (leaf 32))) := rfl

-- Test: subtraction in Karatsuba works correctly with negative coefficients
-- (1, -2) √ó (3, 4) = (3, -2, -8)
-- Represents: (1 - 2*X) * (3 + 4*X) = 3 - 2*X - 8*X¬≤
-- p0 = 1*3 = 3
-- p2 = (-2)*4 = -8
-- p1 = (1-2)*(3+4) - (3 + (-8)) = (-1)*7 - (-5) = -7 + 5 = -2
example : muls (both (leaf (1 : ‚Ñ§)) (leaf (-2))) (both (leaf 3) (leaf 4)) =
    both (both (leaf 3) (leaf (-2))) (left (leaf (-8))) := rfl

-- Test: zero coefficients
-- (0, 1) √ó (2, 0) = (0, 2, 0)
-- Represents: X * 2 = 2*X
example : muls (both (leaf (0 : ‚Ñ§)) (leaf 1)) (both (leaf 2) (leaf 0)) =
    both (both (leaf 0) (leaf 2)) (left (leaf 0)) := rfl

-- Test Tree.mul with different depths
-- Test: leaf √ó left = 3 √ó (5) = (15, 0)
-- Represents: 3 * 5 = 15
example : Tree.mul (leaf (3 : ‚Ñ§)) (left (leaf 5)) =
    left (left (leaf 15)) := rfl

-- Test: left √ó leaf = (2) √ó 5 = (10, 0)
-- Represents: 2 * 5 = 10
example : Tree.mul (left (leaf (2 : ‚Ñ§))) (leaf 5) =
    left (left (leaf 10)) := rfl

-- Test: leaf √ó both = 2 √ó (3, 4) = (6, 8, 0)
-- Represents: 2 * (3 + 4*X) = 6 + 8*X
example : Tree.mul (leaf (2 : ‚Ñ§)) (both (leaf 3) (leaf 4)) =
    left (both (leaf 6) (leaf 8)) := rfl

-- Test: left √ó both with depth mismatch = (2) √ó (3, 4) = (6, 8, 0)
-- Represents: 2 * (3 + 4*X) = 6 + 8*X
example : Tree.mul (left (leaf (2 : ‚Ñ§))) (both (leaf 3) (leaf 4)) =
    left (both (leaf 6) (leaf 8)) := rfl

-- Test: both √ó left with depth mismatch = (2, 3) √ó (5) = (10, 15, 0)
-- Represents: (2 + 3*X) * 5 = 10 + 15*X
example : Tree.mul (both (leaf (2 : ‚Ñ§)) (leaf 3)) (left (leaf 5)) =
    left (both (leaf 10) (leaf 15)) := rfl

-- Test: left(leaf) √ó left(both) = ((2)) √ó ((3, 4)) = (6, 8, 0, 0)
-- Represents: 2 * (3 + 4*X) = 6 + 8*X
-- max(2, 2) + 1 = 3, so result is Tree Œ± 3
example : Tree.mul (left (left (leaf (2 : ‚Ñ§)))) (left (both (leaf 3) (leaf 4))) =
    left (left (both (leaf 6) (leaf 8))) := rfl

-- Test: larger depth mismatch = ((1, 2), (3, 4)) √ó (5)
-- Represents: (1 + 2*X + 3*X¬≤ + 4*X¬≥) * 5 = 5 + 10*X + 15*X¬≤ + 20*X¬≥
-- Input: depth 2 √ó depth 1, result should be depth 3
example : Tree.mul
    (both (both (leaf (1 : ‚Ñ§)) (leaf 2)) (both (leaf 3) (leaf 4)))
    (left (leaf 5)) =
    left (both (both (leaf 5) (leaf 10)) (both (leaf 15) (leaf 20))) := rfl

-- Test: symmetric case - (5) √ó ((1, 2), (3, 4))
example : Tree.mul
    (left (leaf (5 : ‚Ñ§)))
    (both (both (leaf 1) (leaf 2)) (both (leaf 3) (leaf 4))) =
    left (both (both (leaf 5) (leaf 10)) (both (leaf 15) (leaf 20))) := rfl

-- Test: both (depth 1) √ó both (depth 1) = (1, 2) √ó (3, 4)
-- Should use full Karatsuba algorithm
-- Represents: (1 + 2*X) * (3 + 4*X) = 3 + 10*X + 8*X¬≤
example : Tree.mul (both (leaf (1 : ‚Ñ§)) (leaf 2)) (both (leaf 3) (leaf 4)) =
    both (both (leaf 3) (leaf 10)) (left (leaf 8)) := rfl

-- Test: left(both) √ó both = ((1, 2)) √ó (3, 4)
-- Input: depth 2 √ó depth 1
-- Represents: (1 + 2*X) * (3 + 4*X) = 3 + 10*X + 8*X¬≤
example : Tree.mul
    (left (both (leaf (1 : ‚Ñ§)) (leaf 2)))
    (both (leaf 3) (leaf 4)) =
    left (both (both (leaf 3) (leaf 10)) (left (leaf 8))) := rfl

-- Test: both √ó left(both) = (1, 2) √ó ((3, 4))
-- Input: depth 1 √ó depth 2
example : Tree.mul
    (both (leaf (1 : ‚Ñ§)) (leaf 2))
    (left (both (leaf 3) (leaf 4))) =
    left (both (both (leaf 3) (leaf 10)) (left (leaf 8))) := rfl

-- Test: leaf √ó leaf with Tree.mul
example : Tree.mul (leaf (2 : ‚Ñ§)) (leaf 3) =
    left (leaf 6) := rfl

-- Test: another simple case
-- (1, 0) √ó (0, 1) = 0 + X
example : Tree.mul (both (leaf (1 : ‚Ñ§)) (leaf 0)) (both (leaf 0) (leaf 1)) =
    both (both (leaf 0) (leaf 1)) (left (leaf 0)) := rfl

-- Test: with zeros
-- (0, 1) √ó (2, 0) = 2*X
example : Tree.mul (both (leaf (0 : ‚Ñ§)) (leaf 1)) (both (leaf 2) (leaf 0)) =
    both (both (leaf 0) (leaf 2)) (left (leaf 0)) := rfl

-- Test: with negative numbers
-- (-1, 2) √ó (3, -4) = -3 - 2*X + 6*X¬≤ - 8*X¬≥
-- Wait, that's wrong. Let me recalculate:
-- (-1 + 2*X) * (3 - 4*X) = -3 + 4*X + 6*X - 8*X¬≤ = -3 + 10*X - 8*X¬≤
example : Tree.mul (both (leaf (-1 : ‚Ñ§)) (leaf 2)) (both (leaf 3) (leaf (-4))) =
    both (both (leaf (-3)) (leaf 10)) (left (leaf (-8))) := rfl
